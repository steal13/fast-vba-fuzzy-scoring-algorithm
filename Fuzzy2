Option Explicit
'Felipe Costa Gualberto suggested this compiler directive that makes the code work with all VBA versions
#If VBA7 Then
  Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
#Else
  Declare Function GetTickCount Lib "kernel32.dll" () As Long
#End If

Sub AllTests()
Debug.Print vbLf & "Test the amount of time spent in the character cleansing part vs. the whole function, in it's original form"
TestFilterVSWhole
Debug.Print vbLf & "Test the effect of searching A and 9 in ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 with InStr"
TestInStr
Debug.Print vbLf & "Test using the Like operator instead of InStr for filtering characters"
TestInStrVSLike
Debug.Print vbLf & "Test various filter forms"
TestFilters
Debug.Print vbLf & "Test various improvements in the Fuzzy routines"
TestFuzzy
End Sub

Sub TestFuzzy()
  Dim t As Long, a As Single, i As Long, n As Long, s1 As String, s2 As String
  Dim f0 As Single, f1 As Single, f2 As Single, f3 As Single, f4 As Single, f5 As Single, f6 As Single, f7 As Single
  s1 = "Sorin Sion"
  s2 = "Open Source"
  n = 200000
  t = GetTickCount
  For i = 1 To n: a = Fuzzy0(s1, s2): Next
  f0 = GetTickCount - t
  Debug.Print ("Fuzzy0. Similarity score: " & a & "; " & i - 1 & " iterations took " & f0 & " milliseconds. [Original code]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy1(s1, s2): Next
  f1 = GetTickCount - t
  Debug.Print ("Fuzzy1. Similarity score: " & a & "; " & i - 1 & " iterations took " & f1 & " milliseconds. (" & _
        Int(100 * (1 - f1 / f0)) & "% faster). [Mid, Ucase, Left replaced with Mid$, Ucase$, Left$]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy2(s1, s2): Next
  f2 = GetTickCount - t
  Debug.Print ("Fuzzy2. Similarity score: " & a & "; " & i - 1 & " iterations took " & f2 & " milliseconds. (" & _
        Int(100 * (1 - f2 / f0)) & "% faster). [Filtering characters with InStr]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy3(s1, s2): Next
  f3 = GetTickCount - t
  Debug.Print ("Fuzzy3. Similarity score: " & a & "; " & i - 1 & " iterations took " & f3 & " milliseconds. (" & _
        Int(100 * (1 - f3 / f0)) & "% faster). [Filtering with conversion to integers]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy4(s1, s2): Next
  f4 = GetTickCount - t
  Debug.Print ("Fuzzy4. Similarity score: " & a & "; " & i - 1 & " iterations took " & f4 & " milliseconds. (" & _
        Int(100 * (1 - f4 / f0)) & "% faster). [Mid$(s2, p, 1) = '~' instead of s2 = Left(s2, p - 1) & '~' & Mid(s2, p + 1)]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy5(s1, s2): Next
  f5 = GetTickCount - t
  Debug.Print ("Fuzzy5. Similarity score: " & a & "; " & i - 1 & " iterations took " & f5 & " milliseconds. (" & _
        Int(100 * (1 - f5 / f0)) & "% faster). [Optimized, using 'InStr' in filtering]")
  t = GetTickCount
  For i = 1 To n: a = Fuzzy5(s1, s2): Next
  f6 = GetTickCount - t
  Debug.Print ("Fuzzy6. Similarity score: " & a & "; " & i - 1 & " iterations took " & f6 & " milliseconds. (" & _
        Int(100 * (1 - f6 / f0)) & "% faster). [Optimized, using 'Like' operator in filtering]")
  t = GetTickCount
  For i = 1 To n: a = HotFuzz(s1, s2): Next
  f7 = GetTickCount - t
  Debug.Print ("HotFuzz. Similarity score: " & a & "; " & i - 1 & " iterations took " & f7 & " milliseconds. (" & _
        Int(100 * (1 - f7 / f0)) & "% faster). [Optimized, parametrized, using 'Like' operator in filtering]")
End Sub

Sub TestFilterVSWhole()
  Dim t As Long, a As Single, i As Long, n As Long, s1 As String, s2 As String, f0 As Single, fl As Single
  s1 = "Sorin Sion"
  s2 = "Open Source"
  n = 200000
  t = GetTickCount
  For i = 1 To n: a = Fuzzy0(s1, s2): Next
  f0 = GetTickCount - t
  Debug.Print ("Whole Fuzzy0. " & i - 1 & " iterations took " & f0 & " milliseconds. [Original code]")
  t = GetTickCount
  For i = 1 To n: a = Filter0(s1, s2): Next
  fl = GetTickCount - t
  Debug.Print ("Only characters filtering. " & i - 1 & " iterations took " & fl & " milliseconds. (" & _
        Int(100 * (fl / f0)) & "% of total time). [Original character filter]")
End Sub

Sub TestFilters()
  Dim t As Long, a As Single, i As Long, n As Long, s1 As String, s2 As String, f0 As Single, f1 As Single, f2 As Single, f3 As Single, f4 As Single
  s1 = "Sorin Sion"
  s2 = "Open Source"
  n = 200000
  t = GetTickCount
  For i = 1 To n: a = Filter0(s1, s2): Next
  f0 = GetTickCount - t
  Debug.Print (i - 1 & " iterations took " & f0 & " milliseconds. [Original filter, with Select Case]")
  t = GetTickCount
  For i = 1 To n: a = Filter1(s1, s2): Next
  f1 = GetTickCount - t
  Debug.Print (i - 1 & " iterations took " & f1 & " milliseconds. (" & Int(100 * (f1 / f0)) & "% of total time). [InStr]")
  t = GetTickCount
  For i = 1 To n: a = Filter2(s1, s2): Next
  f2 = GetTickCount - t
  Debug.Print (i - 1 & " iterations took " & f2 & " milliseconds. (" & Int(100 * (f2 / f0)) & "% of total time). [Like]")
  t = GetTickCount
  For i = 1 To n: a = Filter3(s1, s2): Next
  f3 = GetTickCount - t
  Debug.Print (i - 1 & " iterations took " & f3 & " milliseconds. (" & Int(100 * (f3 / f0)) & "% of total time). [Parametrized InStr]")
  t = GetTickCount
  For i = 1 To n: a = Filter4(s1, s2): Next
  f4 = GetTickCount - t
  Debug.Print (i - 1 & " iterations took " & f4 & " milliseconds. (" & Int(100 * (f4 / f0)) & "% of total time). [Parametrized Like]")
End Sub

Sub TestInStr()
  Dim t As Long, t1 As Long, t2 As Long, a As Integer, i As Long
  t = GetTickCount
  For i = 1 To 10000000
    a = InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", "A", 0)
  Next
  t1 = GetTickCount - t
  t = GetTickCount
  For i = 1 To 10000000
    a = InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", "9", 0)
  Next
  t2 = GetTickCount - t
  Debug.Print "Finding 9 is " & Format((t2 / t1), "#.0") & " times slower than finding A"
  'finding an '9' takes roughly twice the time to find an 'A' in the ordered string above
  'so optimizing the characters order based on letter probability in the general language makes sense
  'i.e. EIARNUTCLSODPMVFBGZHJXKYWQ0123456789 for Romanian language, according to Adriana Vlad, Adrian Mitrea and Mihai Mitrea: http://www.sepln.org/revistaSEPLN/revista/26/vlad.pdf
End Sub

Sub TestInStrVSLike()
  Dim t As Long, t1 As Long, t2 As Long, a As Integer, i As Long
  t = GetTickCount
  For i = 1 To 20000000
    a = InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", "A", 0)
  Next
  t1 = GetTickCount - t
  t = GetTickCount
  For i = 1 To 20000000
    a = "A" Like "[A-Z#]"
  Next
  t2 = GetTickCount - t
  Debug.Print "Like is " & Int(100 * (1 - t2 / t1)) & "% faster than InStr on letters and numbers"
  '"Like" is ~15% faster than "InStr" on letters and numbers.
  'However, if searching for hyphens or right brackets in an optional manner, supplementary logic is needed
  'in a "Like" filter routine and this cancels the advantage - see Filter3 function
End Sub

Function Fuzzy0(ByVal s1 As String, ByVal s2 As String) As Single
  Dim i As Integer, j As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy0 = 0
  s1 = UCase(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  j = 1
  a1 = ""
  For i = 1 To d1
    c = Mid(s1, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z" 'filter the allowable characters
        a1 = a1 & c 'a1 is what remains from s1 after filtering
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function 'if s1 is empty after filtering
  d1 = j - 1
  s2 = UCase(s2)
  d2 = Len(s2)
  j = 1
  a2 = ""
  For i = 1 To d2
    c = Mid(s2, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z"
        a2 = a2 & c
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function
  d2 = j - 1
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, vbBinaryCompare) > 0 Then
      Fuzzy0 = 1 / d2
    Else
      Fuzzy0 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid(s1, i, 1), vbBinaryCompare)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        s2 = Left(s2, p - 1) & "~" & Mid(s2, p + 1)
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid(s2, p + 1, 1) = Mid(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy0 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy1(ByVal s1 As String, ByVal s2 As String) As Single
'Replacing Mid, Left, Ucase with their string-returning counterparts, Mid$, Left$, Ucase$
'Change suggested by Doug Bliss and cHARLES_wILLIAMS
  Dim i As Integer, j As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy1 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  j = 1
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z" 'filter the allowable characters
        a1 = a1 & c 'a1 is what remains from s1 after filtering
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function 'if s1 is empty after filtering
  d1 = j - 1
  s2 = UCase$(s2)
  d2 = Len(s2)
  j = 1
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z"
        a2 = a2 & c
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function
  d2 = j - 1
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, vbBinaryCompare) > 0 Then
      Fuzzy1 = 1 / d2
    Else
      Fuzzy1 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid$(s1, i, 1), vbBinaryCompare)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        s2 = Left$(s2, p - 1) & "~" & Mid$(s2, p + 1)
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid$(s2, p + 1, 1) = Mid$(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy1 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy2(ByVal s1 As String, ByVal s2 As String) As Single
'Replacing the string filtering (cleansing) routine with an InStr version
'Change suggested by Stuart McLachlan (PNG)
  Dim i As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy2 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c) Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c) Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, vbBinaryCompare) > 0 Then
      Fuzzy2 = 1 / d2
    Else
      Fuzzy2 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid$(s1, i, 1), vbBinaryCompare)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        s2 = Left$(s2, p - 1) & "~" & Mid$(s2, p + 1)
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid$(s2, p + 1, 1) = Mid$(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy2 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy3(ByVal s1 As String, ByVal s2 As String) As Single
'Replacing the string filtering (cleansing) routine with an integer evaluating one
'Change suggested by Malcolm Dixon
  Dim i As Integer, j As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy3 = 0
  s1 = UCase(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid(s1, i, 1)
    j = Asc(c)
    If (j > 47 And j < 58) Or (j > 64 And j < 91) Then
      a1 = a1 & c
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function 'if s1 is empty after filtering
  s2 = UCase(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid(s2, i, 1)
    j = Asc(c)
    If (j > 47 And j < 58) Or (j > 64 And j < 91) Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function 'if s2 is empty after filtering
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, vbBinaryCompare) > 0 Then
      Fuzzy3 = 1 / d2
    Else
      Fuzzy3 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid(s1, i, 1), vbBinaryCompare)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        s2 = Left(s2, p - 1) & "~" & Mid(s2, p + 1)
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid(s2, p + 1, 1) = Mid(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy3 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy4(ByVal s1 As String, ByVal s2 As String) As Single
'Replacing the [s2 = Left(s2, p - 1) & "~" & Mid(s2, p + 1)] line with [Mid$(s2, p, 1) = "~"]
'Change suggested by Stuart McLachlan (PNG) and Doug Bliss
  Dim i As Integer, j As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy4 = 0
  s1 = UCase(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  j = 1
  a1 = ""
  For i = 1 To d1
    c = Mid(s1, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z" 'filter the allowable characters
        a1 = a1 & c 'a1 is what remains from s1 after filtering
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function 'if s1 is empty after filtering
  d1 = j - 1
  s2 = UCase(s2)
  d2 = Len(s2)
  j = 1
  a2 = ""
  For i = 1 To d2
    c = Mid(s2, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z"
        a2 = a2 & c
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function
  d2 = j - 1
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, vbBinaryCompare) > 0 Then
      Fuzzy4 = 1 / d2
    Else
      Fuzzy4 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid(s1, i, 1), vbBinaryCompare)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        Mid(s2, p, 1) = "~"
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid(s2, p + 1, 1) = Mid(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy4 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy5(ByVal s1 As String, ByVal s2 As String) As Single
'Integrating all the suggested optimizations
  Dim i As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy5 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c, 0) Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c, 0) Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, 0) Then
      Fuzzy5 = 1 / d2
    Else
      Fuzzy5 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid$(s1, i, 1), 0)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        Mid$(s2, p, 1) = "~"
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid$(s2, p + 1, 1) = Mid$(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy5 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Fuzzy6(ByVal s1 As String, ByVal s2 As String) As Single
'Integrating string functions replacement and [Mid$(s2, p, 1) = "~"] but using the Like operator in the string filtering routine
  Dim i As Integer, k As Integer, d1 As Integer, d2 As Integer, p As Integer
  Dim c As String, a1 As String, a2 As String, f As Single, o As Single, w As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Fuzzy6 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If c Like "[A-Z0-9]" Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If c Like "[A-Z0-9]" Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, 0) Then
      Fuzzy6 = 1 / d2
    Else
      Fuzzy6 = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid$(s1, i, 1), 0)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        Mid$(s2, p, 1) = "~"
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid$(s2, p + 1, 1) = Mid$(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter
    'because two characters are required to define "order"
    w = 2 'Weight of characters order match against characters frequency match;
    'feel free to experiment, to get best matching results with your data.
    'If only frequency is important, you can get rid of the second Do...Loop
    'to significantly accelerate the code.
    'By altering a bit the code above and the equation below you may get rid
    'of the frequency parameter, since the order counter increments only for
    'identical characters which are in the same order.
    'However, I usually keep both parameters, since they offer maximum flexibility
    'with a variety of data, and both should be maintained for this project
    Fuzzy6 = (w * o + f) / (w + 1) / d2
  End If
End Function

Function Filter0(ByVal s1 As String, ByVal s2 As String) As Single
'Original, Select Case filtering
  Dim i As Integer, j As Integer, d1 As Integer, d2 As Integer
  Dim c As String, a1 As String, a2 As String
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Filter0 = 0
  s1 = UCase(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  j = 1
  a1 = ""
  For i = 1 To d1
    c = Mid(s1, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z" 'filter the allowable characters
        a1 = a1 & c 'a1 is what remains from s1 after filtering
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function 'if s1 is empty after filtering
  d1 = j - 1
  s2 = UCase(s2)
  d2 = Len(s2)
  j = 1
  a2 = ""
  For i = 1 To d2
    c = Mid(s2, i, 1)
    Select Case c
      Case "0" To "9", "A" To "Z"
        a2 = a2 & c
        j = j + 1
    End Select
  Next
  If j = 1 Then Exit Function
  d2 = j - 1
End Function

Function Filter1(ByVal s1 As String, ByVal s2 As String) As Single
'InStr version, suggested by Stuart McLachlan (PNG)
  Dim i As Integer, d1 As Integer, d2 As Integer
  Dim c As String, a1 As String, a2 As String
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Filter1 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c) Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c) Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
End Function

Function Filter2(ByVal s1 As String, ByVal s2 As String) As Single
'Using Like operator for filtering
  Dim i As Integer, d1 As Integer, d2 As Integer
  Dim c As String, a1 As String, a2 As String
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Filter2 = 0
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If c Like "[A-Z0-9]" Then  'filter the allowable characters
        'To match the special characters left bracket ([), question mark (?), number sign (#), and asterisk (*), enclose them in brackets.
        'I.e. to allow for a small letter, a number, the left bracket or the bang sign the pattern string should be "[a-z0-9[!]"
        'The bang sign (!) in the first position after the left bracket is equivalent to "Not Like", so "[!a-z]" is equivalent to "anything which is not a small letter"
        'To match a hyphen, it must be used as the first or last character in the characters list between the brackets, otherwise is interpreted as range-defining
        '# can be used for number matching but only outside brackets. Use 0-9 inside brackets for number matching.
        'The right bracket (]) can't be used within a group to match itself, but it can be used outside a group as an individual character. This leads to coding complications and therefore loss of speed if you need to allow it.
       a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If c Like "[A-Z0-9]" Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
End Function

Function Filter3(ByVal s1 As String, ByVal s2 As String, Optional ByVal n As Boolean = True, Optional ByVal x As String = "") As Single
'InStr version, suggested by Stuart McLachlan (PNG), modified to allow optional supplemental characters in the input strings - passed in the 'x' parameter.
'Use x & Chr(34) if you need to allow double quotes (") in the input strings
'Allowing numbers in the input strings is optional (the 'n' parameter)
  Dim i As Integer, d1 As Integer, d2 As Integer, y As String
  Dim c As String, a1 As String, a2 As String
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Filter3 = 0
  If n Then 'allow numbers in the input strings?
    y = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  Else
    y = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  End If
  y = y & x
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If InStr(y, c) Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If InStr(y, c) Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
End Function

Function Filter4(ByVal s1 As String, ByVal s2 As String, Optional n As Boolean = True, Optional x As String = "") As Single
'Using Like operator for filtering, with added code to allow special characters in the input strings, including hyphen and the right bracket - passed in the 'x' parameter.
'Use x & Chr(34) if you need to allow double quotes (") in the input strings
'Allowing numbers in the input strings is optional (the 'n' parameter)
  Dim i As Integer, d1 As Integer, d2 As Integer, y As String, b As Boolean
  Dim c As String, a1 As String, a2 As String
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  Filter4 = 0
  b = False
  If n Then 'allow numbers in the input strings?
    y = "[A-Z0-9"
  Else
    y = "[A-Z"
  End If
  If Len(x) > 0 Then 'we want to allow some special characters in the input strings, i.e. space, punctuation etc
    If InStr(1, x, "-", 0) Then
      y = Replace(x, "-", "") & "-" 'hyphen must be placed first or last inside a [..] group in a Like comparison
    End If
    If InStr(1, x, "]", 0) Then
      y = Replace(x, "]", "") 'right bracket can't be part of a [..] group in a Like comparison - dedicated logic must be developed to treat this case
      b = True 'if we want to allow the right bracket in the input strings
    End If
  End If
  y = y & "]" 'closing the group
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If c Like y Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    ElseIf b Then
      If c = "]" Then 'special treatment for the right bracket
        a1 = a1 & c
      End If
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If c Like y Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
End Function

Function HotFuzz(ByVal s1 As String, ByVal s2 As String, Optional ByVal n As Boolean = True, Optional ByVal x As String = "", Optional ByVal w As Single = 2) As Single
'Using Like operator for filtering, with added code to allow special characters in the input strings, including hyphen and the right bracket - passed in the 'x' parameter.
'Use x & Chr(34) if you need to allow double quotes (") in the input strings
'Allowing numbers in the input strings is optional (the 'n' parameter)
'The 'w' parameter is the weight of "order" over "frequency" scores in the final score. Feel free to experiment, to get best matching results with your data.
  Dim i As Integer, d1 As Integer, d2 As Integer, y As String, b As Boolean
  Dim c As String, a1 As String, a2 As String, k As Integer, p As Integer, f As Single, o As Single
  '
  '        ******* INPUT STRINGS CLEANSING *******
  '
  HotFuzz = 0
  b = False
  If n Then 'allow numbers in the input strings?
    y = "[A-Z0-9"
  Else
    y = "[A-Z"
  End If
  If Len(x) > 0 Then 'we want to allow some special characters in the input strings, i.e. space, punctuation etc
    If InStr(1, x, "-", 0) Then
      y = Replace(x, "-", "") & "-" 'hyphen must be placed first or last inside a [..] group in a Like comparison
    End If
    If InStr(1, x, "]", 0) Then
      y = Replace(x, "]", "") 'right bracket can't be part of a [..] group in a Like comparison - dedicated logic must be developed to treat this case
      b = True 'if we want to allow the right bracket in the input strings
    End If
  End If
  y = y & "]" 'closing the group
  s1 = UCase$(s1) 'input strings are converted to uppercase
  d1 = Len(s1)
  a1 = ""
  For i = 1 To d1
    c = Mid$(s1, i, 1)
    If c Like y Then  'filter the allowable characters
      a1 = a1 & c 'a1 is what remains from s1 after filtering
    ElseIf b Then
      If c = "]" Then 'special treatment for the right bracket
        a1 = a1 & c
      End If
    End If
  Next
  d1 = Len(a1)
  If d1 = 0 Then Exit Function
  s2 = UCase$(s2)
  d2 = Len(s2)
  a2 = ""
  For i = 1 To d2
    c = Mid$(s2, i, 1)
    If c Like y Then
      a2 = a2 & c
    End If
  Next
  d2 = Len(a2)
  If d2 = 0 Then Exit Function
  k = d1
  If d2 < d1 Then 'to prevent doubling the code below s1 must be made the shortest string,
    'so we swap the variables
    k = d2
    d2 = d1
    d1 = k
    s1 = a2
    s2 = a1
    a1 = s1
    a2 = s2
  Else
    s1 = a1
    s2 = a2
  End If
  If k = 1 Then 'degenerate case, where the shortest string is just one character
    If InStr(1, s2, s1, 0) Then
      HotFuzz = 1 / d2
    Else
      HotFuzz = 0
    End If
  Else        '******* MAIN LOGIC HERE *******
    i = 1
    f = 0
    o = 0
    Do 'count the identical characters in s1 and s2 ("frequency analysis")
      p = InStr(1, s2, Mid$(s1, i, 1), 0)
      'search the character at position i from s1 in s2
      If p > 0 Then   'found a matching character, at position p in s2
        f = f + 1   'increment the frequency counter
        Mid$(s2, p, 1) = "~"
        'replace the found character with one outside the allowable list
        '(I used tilde here), to prevent re-finding
        Do      'check the order of characters
          If i >= k Then Exit Do 'no more characters to search
          If Mid$(s2, p + 1, 1) = Mid$(s1, i + 1, 1) Then
            'test if the next character is the same in the two strings
            f = f + 1 'increment the frequency counter
            o = o + 1 'increment the order counter
            i = i + 1
            p = p + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i >= k Then Exit Do
      i = i + 1
    Loop
    If o > 0 Then o = o + 1 'if we got at least one match, adjust the order counter because two characters are required to define "order"
    HotFuzz = (w * o + f) / (w + 1) / d2
  End If
End Function
